/***************************************************************************
                          isis2.c  -  Descrição
                             -------------------
    Geração              : Wed Jul 13 2011
    copyright            : (C) 2011 por Marcos A. Santos
    email                : msantos@opus-ciencia.com.br
 ***************************************************************************
 -------------------------      HISTORIA CVS    ----------------------------

 $Log$

 ***************************************************************************
 *                                                                         *
 *   Os segmentos de código abaixo são partes integrantes de projetos e    *
 *   iniciativas da ANTRAX TECNOLOGIA LTDA. e portanto protegidos pelas    *
 *   garantias de privacidade dos direitos de propriedade industrial ou    *
 *   intelectual. A ANTRAX reserva-se o direito de publicar ou não tais    *
 *   segmentos de acordo com seu critério. Ficam  portanto proibidas as    *
 *   reproduções de qualquer espécie sem sua prévia autorização.           *
 *                                                                         *
 ***************************************************************************/


#include <p18F4550.h>					// Register definitions
#include "isis2.h"
#include <usart.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <portb.h>
#include <delays.h>
#include <timers.h>

#pragma config WDT=OFF, LVP=OFF, FOSC=HS

//---------------------------------------------------------------------
//Declarations
//---------------------------------------------------------------------
void hp_handler (void);
void lp_handler (void);
void sendEcho(char c);
void splash_msg(void);
void show_prompt(void);
void envie_erro (int erro);
void draw_rule(void);
void repchar(unsigned char c, unsigned char count);
byte lexer(void);
void setup_scr(void);
unsigned int scr_convert (char * s);


//---------------------------------------------------------------------
//Constant Definitions
//---------------------------------------------------------------------
#define	BUF_SIZE		25			// tamanho do buffer

#define EEPROM_SCR              0;

//Defaults para a temporização de disparo dos scr´s
#define MS_TIMERTICK            2.5
#define ROLLOVER                65536
#define SCR_BANDGAP             ROLLOVER-(10 * MS_TIMERTICK)
#define SCR_PULSELENGHT         ROLLOVER-(500 * MS_TIMERTICK)
#define SCR_CYCLEPERIOD         ROLLOVER-(7900 * MS_TIMERTICK)
#define SCR_MEASUREAC           ROLLOVER-(2000 * MS_TIMERTICK)
#define SCR_DEBOUNCE            5
#define SCR_ZEROCROSSBIT        PORTB && 0x01


//---------------------------------------------------------------------
// Variaveis
//---------------------------------------------------------------------
byte scr_phase; // fase do cilo de acionamento de pulsos do tiristor
unsigned int scr_bandgap; // tempo para o acionamanto do primeiro pulso após o zero crossing
unsigned int scr_pulselenght; // largura de pulso do acionamento
unsigned int scr_cycleperiod; // tempo para o acionamento do segundo pulso do scr
unsigned int scr_measureac; // tempo para a medida de tensão da rede
byte scr_cycles = 0; // ciclos desde a ultima virada de segundo
byte scr_mapbyte =0; // pointer para o byte no mapa de acordo com o ciclo
byte scr_mapbit = 0; // pointer para o conjunto de bits dentro do byte de mapa
unsigned long time_on=0; // tempo que o sistema esta ativo (em segundos)
int scr_pwr[3]; // Nivel de potencia para controle dos scrs (3 dispositivos)
byte scr_maskfirst; // mapa de ativaçao de pulsos para o ciclo downstream
byte scr_masklast;  // mapa de ativaçao de pulsos para o ciclo upstream
rom near byte *scr_mapptr1 ; // pointer para o byte no mapa



#pragma romdata scrtable=0x7000
const rom byte SCRTable[2400] = {
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
     0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00,
     0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00,
     0x00, 0x08, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00,
     0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00,
     0x00, 0x20, 0x00, 0x08, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x08, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x20,
     0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
     0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10,
     0x01, 0x00, 0x04, 0x00, 0x10, 0x01, 0x00, 0x04, 0x00, 0x10, 0x01, 0x00, 0x04, 0x00, 0x10, 0x01, 0x00, 0x04, 0x00, 0x10,
     0x02, 0x00, 0x10, 0x01, 0x00, 0x08, 0x01, 0x00, 0x04, 0x00, 0x20, 0x04, 0x00, 0x10, 0x02, 0x00, 0x10, 0x01, 0x00, 0x08,
     0x02, 0x00, 0x10, 0x02, 0x00, 0x10, 0x02, 0x00, 0x10, 0x02, 0x00, 0x10, 0x02, 0x00, 0x20, 0x08, 0x02, 0x00, 0x20, 0x08,
     0x02, 0x00, 0x20, 0x08, 0x02, 0x00, 0x20, 0x08, 0x02, 0x00, 0x20, 0x08, 0x02, 0x00, 0x20, 0x08, 0x02, 0x00, 0x20, 0x08,
     0x04, 0x01, 0x00, 0x10, 0x04, 0x01, 0x00, 0x10, 0x04, 0x01, 0x00, 0x10, 0x04, 0x02, 0x01, 0x00, 0x20, 0x10, 0x08, 0x04,
     0x04, 0x02, 0x01, 0x00, 0x20, 0x10, 0x08, 0x04, 0x01, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x20, 0x08, 0x04,
     0x04, 0x02, 0x01, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x20, 0x10, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
     0x04, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x04, 0x04,
     0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
     0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x21, 0x02,
     0x08, 0x08, 0x10, 0x10, 0x20, 0x21, 0x01, 0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x21, 0x01, 0x02, 0x02,
     0x08, 0x10, 0x10, 0x21, 0x01, 0x02, 0x04, 0x04, 0x08, 0x10, 0x10, 0x21, 0x01, 0x02, 0x04, 0x04, 0x08, 0x10, 0x21, 0x02,
     0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x21, 0x02, 0x02,
     0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x22, 0x08, 0x22,
     0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x21, 0x02, 0x04, 0x08, 0x10, 0x21, 0x02, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22,
     0x08, 0x11, 0x02, 0x08, 0x11, 0x02, 0x08, 0x11, 0x02, 0x08, 0x11, 0x02, 0x08, 0x11, 0x02, 0x08, 0x11, 0x02, 0x08, 0x22,
     0x08, 0x21, 0x04, 0x10, 0x22, 0x08, 0x11, 0x04, 0x08, 0x22, 0x04, 0x11, 0x02, 0x08, 0x21, 0x04, 0x10, 0x22, 0x08, 0x22,
     0x08, 0x22, 0x08, 0x22, 0x04, 0x11, 0x04, 0x11, 0x04, 0x08, 0x22, 0x08, 0x22, 0x08, 0x11, 0x04, 0x11, 0x04, 0x10, 0x22,
     0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22, 0x08, 0x22,
     0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x09,
     0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x09, 0x09, 0x09,
     0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x09, 0x09, 0x09, 0x09, 0x09,
     0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x04, 0x11, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
     0x11, 0x08, 0x24, 0x12, 0x09, 0x04, 0x22, 0x11, 0x08, 0x24, 0x12, 0x09, 0x04, 0x22, 0x11, 0x08, 0x24, 0x12, 0x09, 0x09,
     0x11, 0x08, 0x24, 0x12, 0x09, 0x04, 0x22, 0x11, 0x08, 0x24, 0x12, 0x09, 0x04, 0x22, 0x11, 0x09, 0x09, 0x09, 0x09, 0x09,
     0x12, 0x09, 0x08, 0x24, 0x22, 0x12, 0x09, 0x08, 0x24, 0x22, 0x12, 0x09, 0x08, 0x24, 0x22, 0x12, 0x09, 0x09, 0x09, 0x09,
     0x12, 0x12, 0x09, 0x09, 0x08, 0x24, 0x24, 0x22, 0x12, 0x12, 0x09, 0x09, 0x08, 0x24, 0x24, 0x22, 0x12, 0x12, 0x09, 0x09,
     0x12, 0x12, 0x12, 0x12, 0x09, 0x09, 0x09, 0x09, 0x08, 0x24, 0x24, 0x24, 0x24, 0x22, 0x12, 0x12, 0x12, 0x12, 0x09, 0x09,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x11,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x15,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x15, 0x15,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x15, 0x15, 0x15,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x15, 0x15, 0x15, 0x15,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x15, 0x15, 0x15, 0x15, 0x15,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
     0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29,
     0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x15, 0x15,
     0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x15, 0x15, 0x15,
     0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x12, 0x25, 0x0A, 0x14, 0x29, 0x15, 0x15, 0x15, 0x15, 0x15,
     0x14, 0x2A, 0x15, 0x0A, 0x25, 0x12, 0x29, 0x14, 0x2A, 0x15, 0x0A, 0x25, 0x12, 0x29, 0x14, 0x2A, 0x15, 0x0A, 0x25, 0x15,
     0x14, 0x2A, 0x15, 0x0A, 0x25, 0x12, 0x29, 0x14, 0x2A, 0x15, 0x0A, 0x25, 0x12, 0x29, 0x14, 0x2A, 0x15, 0x15, 0x15, 0x15,
     0x15, 0x0A, 0x29, 0x15, 0x0A, 0x29, 0x15, 0x0A, 0x29, 0x15, 0x0A, 0x29, 0x15, 0x0A, 0x29, 0x15, 0x0A, 0x29, 0x15, 0x15,
     0x15, 0x12, 0x2A, 0x25, 0x15, 0x0A, 0x2A, 0x15, 0x14, 0x2A, 0x29, 0x15, 0x12, 0x2A, 0x25, 0x15, 0x0A, 0x2A, 0x15, 0x15,
     0x15, 0x15, 0x0A, 0x2A, 0x29, 0x15, 0x15, 0x0A, 0x2A, 0x29, 0x15, 0x15, 0x0A, 0x2A, 0x29, 0x15, 0x15, 0x0A, 0x2A, 0x29,
     0x15, 0x15, 0x14, 0x2A, 0x2A, 0x2A, 0x15, 0x15, 0x15, 0x0A, 0x2A, 0x2A, 0x25, 0x15, 0x15, 0x12, 0x2A, 0x2A, 0x29, 0x15,
     0x15, 0x15, 0x15, 0x15, 0x12, 0x2A, 0x2A, 0x2A, 0x2A, 0x25, 0x15, 0x15, 0x15, 0x15, 0x0A, 0x2A, 0x2A, 0x2A, 0x2A, 0x15,
     0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x12, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x25,
     0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
     0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
     0x15, 0x15, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x15,
     0x15, 0x15, 0x15, 0x1D, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17, 0x15, 0x15, 0x15,
     0x15, 0x15, 0x1D, 0x15, 0x15, 0x15, 0x15, 0x1D, 0x15, 0x15, 0x15, 0x15, 0x1D, 0x15, 0x15, 0x15, 0x15, 0x1D, 0x15, 0x15,
     0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x15, 0x35, 0x15,
     0x15, 0x17, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x1D, 0x15, 0x15, 0x17, 0x15, 0x15, 0x15, 0x35, 0x15, 0x15, 0x1D, 0x15,
     0x15, 0x1D, 0x15, 0x15, 0x35, 0x15, 0x15, 0x35, 0x15, 0x15, 0x35, 0x15, 0x17, 0x15, 0x15, 0x17, 0x15, 0x15, 0x17, 0x15,
     0x15, 0x35, 0x15, 0x17, 0x15, 0x15, 0x35, 0x15, 0x17, 0x15, 0x15, 0x35, 0x15, 0x17, 0x15, 0x15, 0x35, 0x15, 0x17, 0x15,
     0x15, 0x35, 0x15, 0x1D, 0x15, 0x1D, 0x15, 0x17, 0x15, 0x15, 0x35, 0x15, 0x1D, 0x15, 0x1D, 0x15, 0x17, 0x15, 0x15, 0x35,
     0x15, 0x35, 0x15, 0x35, 0x15, 0x35, 0x15, 0x35, 0x15, 0x35, 0x15, 0x35, 0x15, 0x35, 0x15, 0x35, 0x15, 0x35, 0x15, 0x35,
     0x17, 0x15, 0x17, 0x15, 0x1D, 0x15, 0x1D, 0x15, 0x35, 0x15, 0x35, 0x17, 0x15, 0x17, 0x15, 0x1D, 0x15, 0x1D, 0x15, 0x35,
     0x17, 0x15, 0x1D, 0x15, 0x35, 0x17, 0x15, 0x1D, 0x15, 0x35, 0x17, 0x15, 0x1D, 0x15, 0x35, 0x17, 0x15, 0x1D, 0x15, 0x35,
     0x17, 0x15, 0x35, 0x17, 0x15, 0x1D, 0x17, 0x15, 0x1D, 0x15, 0x35, 0x1D, 0x15, 0x35, 0x17, 0x15, 0x35, 0x17, 0x15, 0x1D,
     0x17, 0x15, 0x35, 0x17, 0x15, 0x35, 0x17, 0x15, 0x35, 0x17, 0x15, 0x35, 0x17, 0x15, 0x35, 0x1D, 0x17, 0x15, 0x35, 0x1D,
     0x17, 0x15, 0x35, 0x1D, 0x17, 0x15, 0x35, 0x1D, 0x17, 0x15, 0x35, 0x1D, 0x17, 0x15, 0x35, 0x1D, 0x17, 0x15, 0x35, 0x1D,
     0x1D, 0x17, 0x15, 0x35, 0x1D, 0x17, 0x15, 0x35, 0x1D, 0x17, 0x15, 0x35, 0x1D, 0x17, 0x17, 0x15, 0x35, 0x35, 0x1D, 0x1D,
     0x1D, 0x17, 0x17, 0x15, 0x35, 0x35, 0x1D, 0x1D, 0x17, 0x15, 0x35, 0x35, 0x1D, 0x1D, 0x17, 0x17, 0x15, 0x35, 0x1D, 0x1D,
     0x1D, 0x17, 0x17, 0x15, 0x35, 0x35, 0x1D, 0x1D, 0x17, 0x17, 0x15, 0x35, 0x35, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
     0x1D, 0x1D, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x15, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
     0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
     0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x35, 0x37, 0x17,
     0x1D, 0x1D, 0x35, 0x35, 0x35, 0x37, 0x17, 0x17, 0x17, 0x1D, 0x1D, 0x1D, 0x1D, 0x35, 0x35, 0x35, 0x37, 0x17, 0x17, 0x17,
     0x1D, 0x35, 0x35, 0x37, 0x17, 0x17, 0x1D, 0x1D, 0x1D, 0x35, 0x35, 0x37, 0x17, 0x17, 0x1D, 0x1D, 0x1D, 0x35, 0x37, 0x17,
     0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x17, 0x17,
     0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x1D, 0x37,
     0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x17, 0x1D, 0x1D, 0x35, 0x37, 0x17, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37,
     0x1D, 0x37, 0x17, 0x1D, 0x37, 0x17, 0x1D, 0x37, 0x17, 0x1D, 0x37, 0x17, 0x1D, 0x37, 0x17, 0x1D, 0x37, 0x17, 0x1D, 0x37,
     0x1D, 0x37, 0x1D, 0x35, 0x37, 0x1D, 0x37, 0x1D, 0x1D, 0x37, 0x1D, 0x37, 0x17, 0x1D, 0x37, 0x1D, 0x35, 0x37, 0x1D, 0x37,
     0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x35, 0x37,
     0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37,
     0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1F,
     0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1F, 0x1F, 0x1F,
     0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
     0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1D, 0x37, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
     0x37, 0x1D, 0x3D, 0x37, 0x1F, 0x1D, 0x37, 0x37, 0x1D, 0x3D, 0x37, 0x1F, 0x1D, 0x37, 0x37, 0x1D, 0x3D, 0x37, 0x1F, 0x1F,
     0x37, 0x1D, 0x3D, 0x37, 0x1F, 0x1D, 0x37, 0x37, 0x1D, 0x3D, 0x37, 0x1F, 0x1D, 0x37, 0x37, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
     0x37, 0x1F, 0x1D, 0x3D, 0x37, 0x37, 0x1F, 0x1D, 0x3D, 0x37, 0x37, 0x1F, 0x1D, 0x3D, 0x37, 0x37, 0x1F, 0x1F, 0x1F, 0x1F,
     0x37, 0x37, 0x1F, 0x1F, 0x1D, 0x3D, 0x3D, 0x37, 0x37, 0x37, 0x1F, 0x1F, 0x1D, 0x3D, 0x3D, 0x37, 0x37, 0x37, 0x1F, 0x1F,
     0x37, 0x37, 0x37, 0x37, 0x1F, 0x1F, 0x1F, 0x1F, 0x1D, 0x3D, 0x3D, 0x3D, 0x3D, 0x37, 0x37, 0x37, 0x37, 0x37, 0x1F, 0x1F,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x3F,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x3F, 0x3F,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x3F, 0x3F, 0x3F,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x3F, 0x3F, 0x3F, 0x3F,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F,
     0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3F, 0x3F,
     0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x3F, 0x3F, 0x3F,
     0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x37, 0x3F, 0x1F, 0x3D, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3D, 0x3F, 0x3F, 0x1F, 0x3F, 0x37, 0x3F, 0x3D, 0x3F, 0x3F, 0x1F, 0x3F, 0x37, 0x3F, 0x3D, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F,
     0x3D, 0x3F, 0x3F, 0x1F, 0x3F, 0x37, 0x3F, 0x3D, 0x3F, 0x3F, 0x1F, 0x3F, 0x37, 0x3F, 0x3D, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x37, 0x3F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3D, 0x3F, 0x3F, 0x3F, 0x37, 0x3F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3D, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x37, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x37, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x37, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
};



//---------------------------------------------------------------------
//ISR´s
//---------------------------------------------------------------------
#pragma code hp_interrupt = 0x8
void hp_int (void){
	_asm goto hp_handler _endasm
}

#pragma code lp_interrupt = 0x18
void lp_int (void){
	_asm goto lp_handler _endasm
}


#pragma code

#pragma interrupt hp_handler
void hp_handler (void){

    int i;
    byte j,k;
    byte scrtemp1;
    byte scrtemp2;


    // Interrupt é do zero crossing ?
    if (INTCONbits.RBIF){
        // Pino sensor do zero crossing mudou (interrupt on change...)
        // Capture o estado do pino (no caso é o RB7)
        j=(SCR_ZEROCROSSBIT);
        // Queremos somente a transição downstream (senoide caindo do max. para zero)
        if (j!=1){
            // OK! bit == 0 -> transicionou de max para minimo
            // Faça um debouncing para prevenir ruído
            k=j;
            for (i=0; i < SCR_DEBOUNCE ; i++){
                j=(SCR_ZEROCROSSBIT);
                if(j != k){
                    //INTCONbits.RBIE=0;
                    INTCONbits.RBIF=0;
                    return;
                }
            }
            // Estamos de fato em zero crossing ------------------------------------------
            // Obtenha o mapa de acionamento para o ciclo atual
            if (scr_cycles > 60){
                // Viramos o segundo, resete o pointer do mapa e atualize o contador de segundos
                time_on++;
                scr_cycles=0;
                scr_mapbyte=0;
                scr_mapbit=0;
            }
            
            // @TODO : o cycles é usado só para indicação de final do scan na linha do mapa
            // é mais rápido usa-lo ou calcular via mapbyte*mapbit ?
            scr_cycles++;
            // Calcule a coluna (indexadores de byte e bit para o mapa)
            // mapbyte acha a coluna de acordo com o ciclo atual, bit localiza os dois bits dentro do byte.
            if (scr_mapbit > 2){
                scr_mapbyte++;
                scr_mapbit = 0;
            }
            scr_mapbit++;

            scr_maskfirst = 0;
            scr_masklast = 0;
            // Calcule a mascara de acionamento, de acordo com o nivel de potência.
            // Rode por canal
            for (i =0; i <3 ; i++){
                // Verifique primeiro se não é default (0% ou 100%) e calcule se necessário
                if (scr_pwr[i] == 0){
                    // Potencia 0 -> Cortar scr nesse ciclo - bit0 da mascara upstream
                    scr_maskfirst = scr_maskfirst && 0xFE;
                    //No downstream também
                    scr_masklast = scr_masklast && 0xFE;
                }
                else if (scr_pwr[i] == 120){
                    // Potencia máxima -> Scr aciona nesse ciclo
                    scr_maskfirst = scr_maskfirst | (0x01 << i);
                    scr_masklast = scr_masklast | (0x01 << i);
                }
                else{
                    // Nâo é default, calcule então ...
                    // Os bits de enable para essa potencia serão : nivel de potencia (linha da tabela) +
                    // numero do ciclo nesse segundo(coluna da tabela)
                    // Aponte o pointer na tabela
                    scr_mapptr1 = SCRTable + ((scr_pwr[i]-1) * 20 ) + scr_mapbyte;
                    // Obtenha o byte ( que tem o mapa downtream/upstream para 3 ciclos -> os 6 bits lsb
                    // contém : do conjunto de bits 4/5==ciclo 1 até bits 0/1==ciclo3 - bits pares são
                    // o controle do semiciclo downstream.
                    scrtemp1=*scr_mapptr1;
                    if (i==0 && (scrtemp1 !=0)){
                        scrtemp2=0;
                    }
                    // Isole o conjunto de bits no lsb, empurre mapbits (que pode ser o inverso de 1, 2 ou 3) * 2
                    scrtemp1=scrtemp1>>((3-scr_mapbit)*2);
                    // Isole o bit upstream (bit 1 do mapa) já o dowstream está no temp aí em cima
                    scrtemp2 = scrtemp1 >> 1;
                    // Já temos os dois bits (downstream e upstream) isolados, monte a mascara
                    // colocando os bits no lugar correspondente a potencia. Primeiro fixe-os 
                    scrtemp1=scrtemp1 & 0x01;
                    scrtemp2=scrtemp2 & 0x01;
                    // Agora shifte para o lugar (loop vezes a esquerda)
                    scrtemp1 = scrtemp1 << i;
                    scrtemp2 = scrtemp2 << i;
                    // E insira na mascara
                    scr_maskfirst = scr_maskfirst | scrtemp1;
                    scr_masklast = scr_masklast | scrtemp2;
                }
            }
            // Inicie a sequencia de acionamento do timer 0
            scr_phase = 4;
            // Primeiro delay == SCR_BANDGAP == 1uS
            WriteTimer0(scr_bandgap);
            // Timer0 deve contar agora
            T0CONbits.TMR0ON=1;
        }
        //INTCONbits.RBIE=0;
        INTCONbits.RBIF=0;   
        return;
    }

    // Interrupt é do gatilho dos scr´s ?
    else if (INTCONbits.TMR0IF){    
        switch (scr_phase){
            case 0:
                // final da sequencia, meça a linha caso ok e desligue o timer
                T0CONbits.TMR0ON=0;
                break;
            case 4:
                // Acabou o Bandgap, acione o tiristor
                LATD=scr_maskfirst;
                //LATDbits.LATD0 = 1;
                //LATDbits.LATD1 = 1;
                //LATDbits.LATD2 = 1;
                scr_phase=3;
                WriteTimer0(scr_pulselenght);
                break;
            case 3:
                 // Acabou o Holdlengh
                LATD=0;
                LATDbits.LATD1 = 0;
                scr_phase=2;
                WriteTimer0(scr_cycleperiod);
                break;
            case 2:
                // Ciclo Downstream, acione o tiristor
                 LATD=scr_masklast;
                //LATDbits.LATD1 = 1;
                scr_phase=1;
                WriteTimer0(scr_pulselenght);
                break;
            case 1:
                 // Acabou o Holdlengh
                LATD=0;
                LATDbits.LATD1 = 0;
                scr_phase=0;
                WriteTimer0(scr_measureac);
                break;
        }
        INTCONbits.TMR0IF=0;
    }

}

#pragma interrupt lp_handler
void lp_handler (void){

    unsigned char token_in;
    int i;
    
    //Obtenha token do host ou do usuario
    token_in = ReadUSART();
    //Comando OK -> trate-o conforme config 
    if (modo_binario==TRUE) {
    /*O comando binÃ?Â¡rio -----------------------------------------------------------------------*/
      
    }
    else{
        /*O comando Ã?Â© mnemonico -----------------------------------------------------------------------*/
        /*Selecione se o comando estÃ?Â¡ completo (usuario digitou enter) ou estamos construindo a sintaxe */
        if (token_in == CR){
            /*OK - comando completo, verifique e despache ... */
            if (cmd_pos==0){      /*User sÃ?Â³ pressionou enter ? (comando nulo ...) envie sÃ?Â³ o prompt*/
                show_prompt ();
            }
            else{
                /*Linha  de comando terminou e supostamente temos um comando valido,
                adicione o enter (como delimitador para o lexer) e termine a string com NULL */
                cmd[cmd_pos++] = CR;
                cmd[cmd_pos++] = 0;
                /*Agora verifique e execute o comando solicitado */
                if (lexer()== TRUE ){
                /*Lexer executou com sucesso, aguardar proximo comando */
                    if (!modo_binario) {
                        /*Enviar prompt caso em modo mnemonico */
                        show_prompt();
                    }
                }
                else{
                    /*Lexer encontrou erro, sinalize e aguarde proximo comando */
                    envie_erro (ERRO_DE_SINTAXE);
                    show_prompt();
                }
                /*Comando executado, resete o pointer e execute outro loop */
                cmd_pos=0;
            }
        }
        // User estÃ?Â¡ montando o comando
        else if (token_in == '/'){  /* User quer repetir o comando ?  */
            if (cmd_pos==0){
                /*Quer sim, digitou-o no inicio do prompt. Encontre o CR no final do
                Ã?Âºltimo comando, envie o comando de volta para o usuario e ajuste
                o pointer de ediÃ?Â§Ã?Â£o apropriadamente. Retire o CR da estrutura pois
                nÃ?Â£o queremos que o cursor volte ao inicio do prompt. */
                for ( i=0; i < CMD_BUFFER_LEN; i++){
                        if (cmd[i] == CR) {
                            cmd[i]= 0;
                            cmd_pos=i;
                            break;
                        }
                }
                // FaÃ?Â§a o serviÃ?Â§o para o user
                putsUSART(cmd);
            }
            else{
                /*O caracter de repetiÃ?Â§Ã?Â£o de comando estÃ?Â¡Ã?Â¡ no meio da linha, provavelmente
                faz parte de uma linha de comando normal, trate-o como caracter comum */
                cmd[cmd_pos++] = token_in;
                sendEcho(token_in);
            }
        }
        else{
            /*Estamos montando o comando no buffer (token != CR) -------------------------*/
            if (cmd_pos == CMD_BUFFER_LEN){     /* Buffer de comandos esta cheio ? */
                envie_erro (CMD_BUFFER_OVERRUN);
                cmd_pos=0;
            }
            else if (token_in == BKSP){    /* Usuario corrigiu digitÃ?Â§Ã?Â£oo ? */
                /*User digitou Backspace */
                if (!cmd_pos==0){           /*Backspace no inico do prompt nÃ?Â£o faz sentido */
                    /*OK - Envie e ajuste o pointer */
                    sendEcho(token_in);
                    cmd_pos--;
                }
            }
            else{
                /* Caracter normal */
                /*Transfira para maiÃ?Âºsculas */
                if (islower(token_in) != 0) {
                    token_in = toupper(token_in);
                }
                /*E imprima o caracter */
                if (isprint(token_in)!=0){
                    cmd[cmd_pos++] = token_in;
                    sendEcho(token_in);
                }
            }
        }
    }

    /* Clear the interrupt flag */
    PIR1bits.RCIF = 0;

}

/*--------------------------------------------------------------------------*/
byte lexer () {

    register int i;
    register int w;
    register char token1;
  
    byte param_ptr=0;
    byte spflag = FALSE;


    /*Determina verbos, entidades e qualificadores na linha de comando usando o delimitador espaÃ?Â§o. */

    //Desenhe uma rÃ?Â©gua caso esteja em debug
    if (debug == 10) {
        draw_rule();
        putsUSART(cmd);
    }

    /* Execute a varredura de limpeza do buffer */
    for (i=0,w=0; i < CMD_BUFFER_LEN; i++, w++){
   
        token1=cmd[i];

        if (isspace (token1)){
            // EspaÃ?Æ?Ã?Â§o encontrado, considere condicionantes
            if(spflag){
                /*JÃ?Æ?Ã?Â¡Ã?â??Ã?Â¡ havia um espaÃ?Æ?Ã?Â§o anterior ou outro delimitador de parametro, ignore
                portanto o espaÃ?Æ?Ã?Â§o atual e mantenha o pointer fixo */
                w--;
            }
            else{
                //Primeiro espaÃ§o no parametro, mantenha-o de forma a indicar delimitador
                cmd[w]=token1;
                spflag = TRUE;
            }
        }
        else if (token1 == '='){
            //Encontramos equates, contextualize ...
            if (cmd[w-1] == ' '){
                //Havia espaço anterior ao equate, substitua-o pelo dito cujo e fixe o pointer
                w--;
                cmd[w]=token1;
            }
            else {
                /*Operação normal, só insira (lembrar que um equate vale um espaço no parser)
                portanto levante a spflag */
                cmd[w]=token1;
            }
            spflag = TRUE;
        }
        else if (token1 == CR){
            //Final do comando
            cmd[w]=CR;
            cmd [w++]=0;
            break;
        }
        else {
            //Token normal de composição de comando
            cmd[w]=token1;
            spflag = FALSE;
        }
    }


    // Buffer limpou separe os comandos
    //Desenhe uma rÃ©gua caso esteja em debug
    if (debug == 10) {
        putsUSART("Comando Limpo : \r\n");
        draw_rule();
        putsUSART(cmd);
    }

    /* Limpe Ã?rea de parametros */
    for (i=0;i < PARAM_NUM;i++){
        for (w=0;w < PARAM_COMP;w++){
            param [i] [w]=0;
        }
    }
    w=0;

    /* Execute o parse dos comandos  */
    for (i=0;i < CMD_BUFFER_LEN;i++){
        token1=cmd[i];
        /* Delimitador ? */
        if (token1 == ' ' || token1 == '='){
            param_ptr++;
            w=0;
        }
        else if (!token1 || token1 == CR) {
            /* Fim da linha de comando */
            break;
        }
        else {
            /*Copiar parametro no slot correspondente,
            Verifique overflow no slot tambÃ?Æ?Ã?Â©m */
            if (w < PARAM_COMP-1) {
                param[param_ptr] [w] = token1;
                w++;
            }
            else{
                // Parametro estourou o slot, desista e anuncie
                return FALSE;
            }
        }
    }

    // Mostre os dados de Debug caso solicitado
    if (debug == 10) {
        CRLF  ; repchar('-',14); CRLF ;
        putsrom " Mapa da Area de Parametros ");
        CRLF ;

        for (i=0;i < 10;i++){
            printf ("\r\n\tParam[%02d]= ", i);
            putsUSART (param[i]);
        }
        CRLF ; repchar('-',78); CRLF ;
    }

     if (!strcmppgm2ram(param[0], "DEBUG")) {
        debug = atoi(param[1]);
        printf ("Nivel de Debug ajustado p/ : %d \r\n", debug);
        return TRUE;
    }


    // Mostra status das flags de habilitaçao e outros quetais
    if (!strcmppgm2ram(param[0], "INFO")) {
        CRLF;
        printf ("SCR -> Largura de Pulso : %u \r\n", scr_pulselenght); //(unsigned int)(65536 - scr_pulselenght));
        printf ("SCR -> Bandgap : %u \r\n", scr_bandgap);
        printf ("SCR -> Tempo de Ciclo : %u \r\n", scr_cycleperiod);
        printf ("SCR -> Trigger da medida de AC : %u \r\n", scr_measureac);
        return TRUE;
    }

    // Mostra status das flags de habilitação e outros quetais
    if (!strcmppgm2ram(param[0], "SET")) {
        CRLF;
        if (!strcmppgm2ram(param[1], "SCR")) {
            if (!strcmppgm2ram(param[2], "CICLO")) {
                scr_cycleperiod = scr_convert(param[3]);
                printf ("SCR->Ciclo : %u \r\n", scr_cycleperiod);
                return TRUE;
            }
            if (!strcmppgm2ram(param[2], "PULSO")) {
                scr_pulselenght = scr_convert(param[3]);
                printf ("SCR->Largura do pulso : %u \r\n", scr_pulselenght);
                return TRUE;
            }
            if (!strcmppgm2ram(param[2], "BANDGAP")) {
                scr_bandgap = scr_convert(param[3]);
                printf ("SCR->BandGap : %u \r\n", scr_bandgap);
                return TRUE;
            }
            if (!strcmppgm2ram(param[2], "MEDLINHA")) {
                scr_measureac = scr_convert(param[3]);
                printf ("SCR->Medida da Linha : %u \r\n", scr_measureac);
                return TRUE;
            }
        }
        if (!strcmppgm2ram(param[1], "POT")) {
            if (!strcmppgm2ram(param[2], "1")) {
                scr_pwr[0]=atoi(param[3]);
                printf ("POT 1 : %d \r\n", scr_pwr[0]);
                return TRUE;
            }
            if (!strcmppgm2ram(param[2], "2")) {
                scr_pwr[1]=atoi(param[3]);
                printf ("POT 2 : %d \r\n", scr_pwr[1]);
                return TRUE;
            }
            if (!strcmppgm2ram(param[2], "3")) {
                scr_pwr[2]=atoi(param[3]);
                printf ("POT 3 : %d \r\n", scr_pwr[2]);
                return TRUE;
            }
        }
        return FALSE;
    }

   
    return FALSE;
}

/**
 * 
 * @param s
 * @return 
 */
unsigned int scr_convert (char * s){

    unsigned int temp;

    temp=(unsigned int)atoi(s);
    temp = (unsigned int)(65536 - (temp * MS_TIMERTICK));
    return temp;
}



/*--------------------------------------------------------------------------*/
void splash_msg(){
           //1234567890123456789012345678901234567890123456789012345678901234567890123456789
    CRLF ; repchar('-',78); CRLF ;
    putsrom "Controlador Centauro - build 08.1 \r\n");
    putsrom "Segmentos de Codigo - Direitos Reservados \r\n");
    putsrom "ANTRAX TECNOLOGIA ELETRONICA Ltda. - 2010/2011 \r\n");
    repchar('-',78); CRLF ;
}

/*--------------------------------------------------------------------------*/
void repchar(unsigned char c, unsigned char count){
    while (count != 0 ){
        sendEcho(c);
        count--;
    }
}

/*--------------------------------------------------------------------------*/
void show_prompt(){
    putsrom "\r\nCENTAURO:>");
}

void draw_rule(){
    putsrom "\n\r1234567890123456789012345678901234567890\n\r");
}

/*--------------------------------------------------------------------------*/
void envie_erro (int erro){

    switch(erro){
        case CMD_BUFFER_OVERRUN:
            if (modo_binario) {
                putsrom "OPCBUFOV\r") ;
            }
            else{
                putsrom "\r\nErro !! - Overrun no buffer de comandos");
            }
            break;
        case ERRO_DE_SINTAXE:
            if (modo_binario) {
                putsrom "OPCSINTX\r");
            }
            else{
                putsrom "\r\nErro !! - Comando Desconhecido");
            }     
            break;
    }
}

void sendEcho( char c){		
	while (BusyUSART());
	WriteUSART(c);
}

void setup_scr(void){
    
    scr_bandgap = SCR_BANDGAP;
    scr_pulselenght = SCR_PULSELENGHT;
    scr_cycleperiod = SCR_CYCLEPERIOD;
    scr_measureac = SCR_MEASUREAC;

    scr_pwr[0]=1;
    scr_pwr[1]=50;
    scr_pwr[2]=90;
    
}

void main (void){

    /* Configure all PORTD pins for output */
    TRISD = 0;
    TRISB = 0xFF;


    OpenUSART (USART_TX_INT_OFF &
          USART_RX_INT_ON &
          USART_ASYNCH_MODE &
          USART_EIGHT_BIT &
          USART_CONT_RX &
          USART_BRGH_HIGH, 64);

   /* Display a prompt to the USART */
   splash_msg();
   show_prompt();


   setup_scr();
   // habilite interrupts no port B
   INTCON2bits.RBIP=1;
   INTCONbits.RBIE=1;
   // Configure o timer 0 para controle do ciclo de disparo
   T0CON=0;
   INTCONbits.TMR0IE = 1;   // interrupts on timer0
   INTCON2bits.TMR0IP = 1;  // interrupt priority = high



   /* Enable interrupt priority */
   RCONbits.IPEN = 1;

   /* Make receive interrupt low priority */
   IPR1bits.RCIP = 0;

   /* Enable all high priority interrupts */
   INTCONbits.GIEH = 1;
   /* Also the low priority interrupts */
   INTCONbits.GIEL = 1;

   /* Loop forever */
   while (1)
	;
}
